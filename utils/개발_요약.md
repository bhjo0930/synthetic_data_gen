# 가상 인물 데이터 처리 및 분석 프로젝트 요약

## 1. 프로젝트 목표

이 프로젝트의 목표는 초기 가상 인물 데이터를 바탕으로 Gemini AI 모델을 사용하여 데이터를 풍부하게 만들고, 생성된 페르소나를 기반으로 추가적인 분석을 수행하는 파이프라인을 구축하는 것입니다.

## 2. 핵심 기능 및 요구사항

지금까지 개발된 기능은 다음과 같은 세 가지 주요 요구사항으로 나눌 수 있습니다.

### 요구사항 1: 데이터 افزود (Enrichment)

- **목표**: 원본 데이터에 '라이프스타일'과 '성격특성(MBTI)' 정보를 AI 모델로 추정하여 추가합니다.
- **구현 스크립트**: `process_data.py`
- **주요 기능**:
    - Excel(`xlsx`) 또는 CSV(`.csv`) 형식의 원본 데이터를 입력받습니다.
    - `.env` 파일에 저장된 `GEMINI_API_KEY`를 사용하여 Google Gemini 모델에 연결합니다.
    - `segment.xlsx` 파일의 '세그먼트명' 열을 참조하여 각 인물의 라이프스타일을 추정합니다.
    - 각 인물의 데이터를 기반으로 MBTI 성격 유형을 추정합니다.
    - 최종 결과는 Looker Studio와 호환성이 좋은 CSV 파일 (`..._CONV.csv`)로 저장됩니다.
    - `--task` 파라미터 (`lifestyle`, `mbti`, `all`)를 통해 원하는 작업만 선택적으로 수행할 수 있습니다.

### 요구사항 2: 페르소나 기반 질의응답

- **목표**: افزود된 데이터의 각 행(가상 인물)을 하나의 페르소나로 설정하고, 주어진 질문에 대한 답변을 생성합니다.
- **구현 스크립트**: `ask_personas.py`
- **주요 기능**:
    - `..._CONV.csv` 파일을 입력받습니다.
    - 각 행의 모든 데이터를 특정 페르소나의 정보로 간주합니다.
    - "독서 빈도"에 대한 질문을 각 페르소나에게 던지고, Gemini 모델을 통해 페르소나에 몰입한 답변을 생성합니다.
    - 결과를 `이름 | 답변` 형식으로 `result.txt` 파일에 저장합니다.

### 요구사항 3: 데이터 형식 변환

- **목표**: Excel 형식의 파일을 범용적인 CSV 형식으로 변환합니다.
- **구현 스크립트**: `convert_to_csv.py`
- **주요 기능**:
    - 데이터 분석 도구(e.g., Looker Studio)와의 호환성 문제를 해결하기 위해 Excel 파일을 CSV 파일로 변환합니다.
    - 한글 깨짐을 방지하기 위해 `utf-8-sig` 인코딩을 사용합니다.

---

## 3. 전체 코드

### 3.1. `process_data.py`

```python
import pandas as pd
import sys
import os
from dotenv import load_dotenv
import google.generativeai as genai
from tqdm import tqdm

# .env 파일에서 환경 변수 로드
load_dotenv()

# API 키 설정
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY or GEMINI_API_KEY == "YOUR_API_KEY_HERE":
    print("오류: .env 파일에 GEMINI_API_KEY를 설정해야 합니다.")
    sys.exit(1)

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.5-flash')

def get_lifestyle_prompt(row_data, segment_names):
    """라이프스타일 추정을 위한 프롬프트를 생성합니다."""
    prompt = f"""다음은 한 사람의 인구통계 및 행동 데이터입니다.
---
{row_data}
---
위 데이터를 바탕으로, 이 사람에게 가장 적합한 라이프스타일 세그먼트를 아래 목록에서 하나만 골라주세요. 다른 설명 없이 세그먼트 이름만 정확하게 반환해야 합니다.

세그먼트 목록: {', '.join(segment_names)}
"""
    return prompt

def get_mbti_prompt(row_data):
    """MBTI 추정을 위한 프롬프트를 생성합니다."""
    prompt = f"""다음은 한 사람의 인구통계 및 행동 데이터입니다.
---
{row_data}
---
위 데이터를 바탕으로, 이 사람의 MBTI 유형을 16가지 유형(ISTJ, ISFJ, INFJ, INTJ, ISTP, ISFP, INFP, INTP, ESTP, ESFP, ENFP, ENTP, ESTJ, ESFJ, ENFJ, ENTJ) 중에서 추정해주세요. 다른 설명 없이 가장 가능성이 높은 MBTI 유형 하나만 정확하게 반환해야 합니다.
"""
    return prompt

def estimate_lifestyle(data, segment_names):
    """gemini-1.5-flash를 사용하여 '라이프스타일' 열을 추정합니다."""
    print("라이프스타일 추정을 시작합니다...")
    if not segment_names:
        print("경고: 세그먼트 이름이 없어 라이프스타일 추정을 건너뜁니다.")
        if '라이프스타일' not in data.columns:
            data['라이프스타일'] = "미분류"
        return data

    results = []
    for index, row in tqdm(data.iterrows(), total=data.shape[0], desc="라이프스타일 추정 중"):
        row_data_str = '\n'.join([f"{col}: {val}" for col, val in row.items()])
        prompt = get_lifestyle_prompt(row_data_str, segment_names)
        try:
            response = model.generate_content(prompt)
            lifestyle = response.text.strip()
            if lifestyle not in segment_names:
                lifestyle = "분류 오류"
            results.append(lifestyle)
        except Exception as e:
            print(f"  - 행 {index} 처리 중 오류 발생: {e}")
            results.append("오류")
    
    data['라이프스타일'] = results
    print("라이프스타일 추정이 완료되었습니다.")
    return data

def estimate_mbti(data):
    """gemini-1.5-flash를 사용하여 '성격특성' (MBTI) 열을 추정합니다."""
    print("MBTI 추정을 시작합니다...")
    mbti_types = ["ISTJ", "ISFJ", "INFJ", "INTJ", "ISTP", "ISFP", "INFP", "INTP", "ESTP", "ESFP", "ENFP", "ENTP", "ESTJ", "ESFJ", "ENFJ", "ENTJ"]
    results = []
    for index, row in tqdm(data.iterrows(), total=data.shape[0], desc="MBTI 추정 중"):
        row_data_for_prompt = row.drop('성격특성', errors='ignore')
        row_data_str = '\n'.join([f"{col}: {val}" for col, val in row_data_for_prompt.items()])
        prompt = get_mbti_prompt(row_data_str)
        try:
            response = model.generate_content(prompt)
            mbti = response.text.strip().upper()
            if mbti not in mbti_types:
                mbti = "분류 오류"
            results.append(mbti)
        except Exception as e:
            print(f"  - 행 {index} 처리 중 오류 발생: {e}")
            results.append("오류")

    data['성격특성'] = results
    print("MBTI 추정이 완료되었습니다.")
    return data

def process_data(input_file, task="all"):
    """데이터를 읽고, 선택된 작업(라이프스타일/MBTI)을 추정한 후, 새로운 CSV 파일로 저장합니다."""
    try:
        print(f"'{input_file}'에서 데이터를 읽고 있습니다...")
        # 입력 파일 확장자에 따라 다르게 읽기
        if input_file.endswith('.xlsx'):
            df = pd.read_excel(input_file)
        elif input_file.endswith('.csv'):
            df = pd.read_csv(input_file)
        else:
            print(f"오류: 지원하지 않는 파일 형식입니다: {input_file}")
            return

        segment_names = []
        if task == "lifestyle" or task == "all":
            try:
                segment_df = pd.read_excel("segment.xlsx")
                if '세그먼트명' in segment_df.columns:
                    segment_names = segment_df['세그먼트명'].dropna().astype(str).tolist()
                    print(f"'segment.xlsx'의 '세그먼트명' 열에서 다음 세그먼트 목록을 사용합니다: {segment_names}")
                else:
                    print("경고: 'segment.xlsx' 파일에 '세그먼트명' 열이 없습니다.")
            except FileNotFoundError:
                print("경고: 'segment.xlsx' 파일을 찾을 수 없습니다. 라이프스타일 추정을 건너뜁니다.")

        if task == "lifestyle" or task == "all":
            df = estimate_lifestyle(df, segment_names)

        if task == "mbti" or task == "all":
            df = estimate_mbti(df)

        # 결과를 CSV 파일로 저장
        output_file = os.path.splitext(input_file)[0] + '_CONV.csv'
        print(f"처리된 데이터를 '{output_file}' 파일로 저장합니다...")
        df.to_csv(output_file, index=False, encoding='utf-8-sig')
        print("성공적으로 저장되었습니다.")

    except FileNotFoundError:
        print(f"오류: '{input_file}' 파일을 찾을 수 없습니다.")
    except Exception as e:
        print(f"오류가 발생했습니다: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("사용법: python process_data.py <입력_파일> [--task lifestyle|mbti|all]")
        print("예시: python process_data.py Virtual_People_Data_20250820_1545.xlsx --task lifestyle")
        sys.exit(1)

    input_filename = sys.argv[1]
    task_to_run = "all"  # 기본값

    if "--task" in sys.argv:
        try:
            task_index = sys.argv.index("--task") + 1
            if task_index < len(sys.argv):
                task_to_run = sys.argv[task_index]
            else:
                raise ValueError
        except (ValueError, IndexError):
            print("오류: --task 플래그 뒤에 작업(lifestyle, mbti, all)을 지정해야 합니다.")
            sys.exit(1)
    
    if task_to_run not in ["lifestyle", "mbti", "all"]:
        print(f"오류: 알 수 없는 작업 '{task_to_run}'. 'lifestyle', 'mbti', 또는 'all'을 사용하세요.")
        sys.exit(1)

    process_data(input_filename, task=task_to_run)
```

### 3.2. `ask_personas.py`

```python
import pandas as pd
import sys
import os
from dotenv import load_dotenv
import google.generativeai as genai
from tqdm import tqdm

# .env 파일에서 환경 변수 로드
load_dotenv()

# API 키 설정
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
if not GEMINI_API_KEY or GEMINI_API_KEY == "YOUR_API_KEY_HERE":
    print("오류: .env 파일에 GEMINI_API_KEY를 설정해야 합니다.")
    sys.exit(1)

genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.5-flash')

def get_persona_prompt(persona_name, persona_data):
    """페르소나 기반 질문을 위한 프롬프트를 생성합니다."""
    question = "9월은 책 읽기 좋은 계절인데요, 여러분은 독서를 얼마나 자주 하시나요?"
    options = [
        "1. 거의 매일",
        "2. 일주일에 2~3번",
        "3. 일주일에 한 번",
        "4. 한 달에 1~2번",
        "5. 2~3개월에 한 번",
        "6. 이보다 드물게",
        "7. 아예 읽지 않는다"
    ]
    
    prompt = f"""당신은 아래와 같은 특징을 가진 가상 인물 '{persona_name}'입니다. 이 페르소나에 몰입해서 다음 질문에 답해주세요.

--- 페르소나 정보 ---
{persona_data}
---------------------

질문: {question}

아래 선택지 중에서 가장 적절한 답변 하나를 골라 '번호. 내용' 형식으로만 답해주세요. 다른 설명은 필요 없습니다.

--- 선택지 ---
{''.join([f"{opt}\n" for opt in options])}---------------------
"""
    return prompt

def ask_personas(input_file):
    """CSV 파일의 각 행을 페르소나로 하여 질문하고 결과를 파일에 저장합니다."""
    output_filename = "result.txt"
    try:
        print(f"'{input_file}'에서 페르소나 데이터를 읽고 있습니다...")
        df = pd.read_csv(input_file)

        if '이름' not in df.columns:
            print("오류: 입력 파일에 '이름' 열이 없습니다.")
            return

        all_results = []
        for index, row in tqdm(df.iterrows(), total=df.shape[0], desc="페르소나에게 질문 중"):
            persona_name = row['이름']
            persona_data_str = '\n'.join([f"{col}: {val}" for col, val in row.items()])
            prompt = get_persona_prompt(persona_name, persona_data_str)
            
            try:
                response = model.generate_content(prompt)
                answer = response.text.strip()
                formatted_result = f"{persona_name} | {answer}"
                all_results.append(formatted_result)
            except Exception as e:
                print(f"  - {persona_name} 페르소나 처리 중 오류 발생: {e}")
                all_results.append(f"{persona_name} | 답변 생성 오류")

        print(f"모든 답변을 '{output_filename}' 파일에 저장합니다...")
        with open(output_filename, 'w', encoding='utf-8') as f:
            f.write('\n'.join(all_results))
        print("성공적으로 저장되었습니다.")

    except FileNotFoundError:
        print(f"오류: '{input_file}' 파일을 찾을 수 없습니다.")
    except Exception as e:
        print(f"오류가 발생했습니다: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        input_filename = sys.argv[1]
        ask_personas(input_filename)
    else:
        print("사용법: python ask_personas.py <입력_CSV_파일>")
        print("예시: python ask_personas.py Virtual_People_Data_20250820_1545_CONV.csv")
```

### 3.3. `convert_to_csv.py`

```python
import pandas as pd
import sys
import os

def convert_excel_to_csv(input_file):
    """
    Reads an Excel file and saves it as a CSV with 'utf-8-sig' encoding.
    """
    if not input_file.endswith('.xlsx'):
        print("오류: 입력 파일은 .xlsx 형식이어야 합니다.")
        return

    try:
        print(f"'{input_file}' 파일을 읽고 있습니다...")
        df = pd.read_excel(input_file)

        output_file = os.path.splitext(input_file)[0] + '.csv'
        
        print(f"'{output_file}' 파일로 변환하여 저장합니다...")
        df.to_csv(output_file, index=False, encoding='utf-8-sig')
        
        print("성공적으로 변환되었습니다.")

    except FileNotFoundError:
        print(f"오류: '{input_file}' 파일을 찾을 수 없습니다.")
    except Exception as e:
        print(f"오류가 발생했습니다: {e}")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        convert_excel_to_csv(sys.argv[1])
    else:
        print("사용법: python convert_to_csv.py <입력_Excel_파일.xlsx>")
```